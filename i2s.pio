; An I2S full duplex slave with an associated output dual rate I2S port.
;
; Uses a set of 7 pins
;
; DO DI BCLK LRCLK    DO BCLKx2 LRCLKx2
;


.program i2s_in
; I2S audio input slaved from clock
; Input pin order: DIN, BCK, LRCK

frame:
    nop           [28]
    nop           [31]
 .wrap_target
    in pins, 1    [31]
    push noblock  [31]
bit:
    in pins, 1    [31]
    jmp y-- bit   [31]
    in pins, 1  
public entry_point:
    set y, 29     
    jmp x-- frame
    set x,3
    wait 1  pin 0       ;   Sync on the falling edge of LRCLK
    wait 0  pin 0 [31]  ;
.wrap




.program i2s_double
; I2S audio output master running at 2x the i2s_duplex block (using same input framing).
; Assumes the i2s_double_clock engine is running, and that everything is aligned with
; falling edge of the half rate LR clock.
;
; Input pin order: LRCK (single speed)
; Output order:    DOx2 (double speed)

frame:
    nop           [15];
.wrap_target
    out pins, 1   [15]
    pull noblock  [15]  ;
bit:
    out pins, 1   [15]
    jmp y-- bit   [15]
    out pins, 1   [13]
public entry_point:
    set y, 29 
    jmp x-- frame
    set x, 3
    wait 1  pin 0       ;   Sync on the falling edge of LRCLK
    wait 0  pin 0       ;
.wrap



.program i2s_double_clk
; Create the clock I2S audio output master running at 2x the i2s_duplex block (using same input framing).
;
; Input pin order: BCK    LRCLK
; Output order:    BCKx2 (side)   LRCLKx2 (out)
;
; The X and Y registers are initialized to zero in the C code, so first run will fall through

.side_set 1

bit:
    wait 1 pin 0            side 1          ; Really make sure there is a clock
    wait 0 pin 0            side 1          ; Sync to the falling edge of BCLK    
.wrap_target
    mov pins, !x    [15]    side 0          ; Our new LR clock comes from LSB of x - counting frames
    nop             [15]    side 1          ;
    jmp y-- bit     [15]    side 0          ; 
public entry_point:
    set  y, 15              side 1          ; 16 old BCLK bits in each new 2x frame
    jmp x-- bit             side 1          ;
    set  x, 3               side 1          ; Four frames make up a full 48kHz I2S cycle
    wait 1 pin 1            side 1          ; Sync to our LR clock
    wait 0 pin 1            side 1          ; 
.wrap




% c-sdk {

static inline void i2s_double_clk_init(PIO pio, int in, int out, int divN, int divF ) 
{
    uint8_t sm     = pio_claim_unused_sm(pio, true);
    uint    offset = pio_add_program    (pio, &i2s_double_clk_program);
    pio_sm_set_clkdiv_int_frac          (pio, sm, divN, divF);

    pio_gpio_init(pio, in);             // The BCLK
    pio_gpio_init(pio, in+1);           // The LRCLK
    pio_gpio_init(pio, out);            // The BCLKx2
    pio_gpio_init(pio, out+1);          // The LRCLKx2

    pio_sm_config sm_config = i2s_double_clk_program_get_default_config(offset);
    sm_config_set_out_pins     (&sm_config, out+1, 1);
    sm_config_set_in_pins      (&sm_config, in);
    sm_config_set_sideset_pins (&sm_config, out);
    pio_sm_init(pio, sm, offset + i2s_double_clk_offset_entry_point, &sm_config);
    pio_sm_exec_wait_blocking  (pio, sm, pio_encode_mov (pio_x, pio_null));     // Initialize the X and Y registers
    pio_sm_exec_wait_blocking  (pio, sm, pio_encode_mov (pio_y, pio_null));   

    uint32_t pin_mask = 3 << (out);                   // Two output pins
    pio_sm_set_pins_with_mask(pio, sm, 0, pin_mask); 
    pio_sm_set_pindirs_with_mask(pio, sm, pin_mask, pin_mask);
    pin_mask = (3 << in);                             // Two input pins
    pio_sm_set_pindirs_with_mask(pio, sm, 0, pin_mask);
}


static inline void i2s_double_init(PIO pio, int lrclk, int out, int divN, int divF ) 
{
    uint8_t sm     = pio_claim_unused_sm(pio, true);
    uint    offset = pio_add_program    (pio, &i2s_double_program);
    pio_sm_set_clkdiv_int_frac          (pio, sm, divN, divF);

    pio_gpio_init(pio, lrclk);        // LRCLK in at half rate
    pio_gpio_init(pio, out);          // Data

    pio_sm_config sm_config = i2s_double_program_get_default_config(offset);
    sm_config_set_out_pins     (&sm_config, out, 1);
    sm_config_set_in_pins      (&sm_config, lrclk);
    sm_config_set_out_shift    (&sm_config, false, false, 32);
    pio_sm_init(pio, sm, offset + i2s_double_offset_entry_point, &sm_config);
    pio_sm_exec_wait_blocking  (pio, sm, pio_encode_mov (pio_x, pio_null));     // Initialize the X and Y registers
    pio_sm_exec_wait_blocking  (pio, sm, pio_encode_mov (pio_y, pio_null));   
//    pio->txf[sm] = 0;                                                         // Load for spurious pull on first pass

    uint32_t pin_mask = (1 << out);                             // Only one output
    pio_sm_set_pins_with_mask(pio, sm, 0, pin_mask); 
    pio_sm_set_pindirs_with_mask(pio, sm, pin_mask, pin_mask);
    pin_mask = (1 << lrclk);                                    // Everything synced off LR clock normal rate
    pio_sm_set_pindirs_with_mask(pio, sm, 0, pin_mask);

}

static inline void i2s_in(PIO pio, uint8_t sm, uint8_t offset, uint8_t pin_base) 
{
    pio_gpio_init(pio, pin_base + 0);       // DO
    pio_gpio_init(pio, pin_base + 1);       // DI
    pio_gpio_init(pio, pin_base + 2);       // BCLK
    pio_gpio_init(pio, pin_base + 3);       // LRCLK

    pio_sm_config sm_config = i2s_in_program_get_default_config(offset);
    sm_config_set_out_pins (&sm_config, pin_base, 1);
    sm_config_set_in_pins  (&sm_config, pin_base + 1);
    sm_config_set_jmp_pin  (&sm_config, pin_base + 3);
    sm_config_set_out_shift(&sm_config, false, false, 0);
    sm_config_set_in_shift (&sm_config, false, false, 0);
    pio_sm_init(pio, sm, offset, &sm_config);

    uint32_t pin_mask = (0b0000001 << pin_base);            // Single output pin
    pio_sm_set_pins_with_mask(pio, sm, 0, pin_mask); 
    pio_sm_set_pindirs_with_mask(pio, sm, pin_mask, pin_mask);

    pin_mask = (0b00001110 << pin_base);                    // Three input pins
    pio_sm_set_pindirs_with_mask(pio, sm, 0, pin_mask);
}

%}