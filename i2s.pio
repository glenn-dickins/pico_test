; An I2S full duplex slave with an associated output dual rate I2S port.
;
; Uses a set of 7 pins
;
; DO DI BCLK LRCLK    DO BCLKx2 LRCLKx2
;

.program tdm_in
; TDM 8 channel audio slaved from clock
; Input pin: D0
; JMP pin:   LRCK
; Still expects a 50% LR CLK duty cycle
; And falling edge LR is the start of frame


public entry_point: 
    set x, 7
    set y, 29
stall1:
    jmp pin stall1      ; Wait for falling edge of LRCLK
    jmp bit       [23]  ; First bit of first word on second rising
frame:
    nop           [12]
.wrap_target
    in pins, 1    [7]
    push noblock  [7]
bit:
    in pins, 1    [7]
    jmp y-- bit   [7]
    in pins, 1  
start:
    set y, 29     
    jmp x-- frame
stall:
    jmp pin stall        ; Wait for fall of LRCLK
    set x,7        [7] 
.wrap


.program i2s_in
; I2S channel audio slaved from clock
; Input pin: D0 
; JMP pin:   LRCK
; 50% LR CLK duty cycle
; And falling edge LR is the start of frame


public entry_point: 
    set x, 1
    set y, 29
stall1:
    jmp pin stall1      ; Wait for falling edge of LRCLK
    nop           [31]  ;
    nop           [31]
    jmp bit       [31]  ; First bit of first word on second rising
frame:
    nop           [12]
.wrap_target
    in pins, 1    [31]
    push noblock  [31]
bit:
    in pins, 1    [31]
    jmp y-- bit   [31]
    in pins, 1  
start:
    set y, 29     
    jmp x-- frame
stall:
    jmp pin stall        ; Wait for fall of LRCLK
    set x,1        [31] 
.wrap



.program i2s_double_out
; I2S audio output master running at 2x the i2s_duplex block (using same input framing).
;
; Input pin order: BCLK
; Output order:    DO    BCKx2, LRCKx2 (side)
; Jump pin         LRCLK
; 
; No idea why, but a wait 0 pin 1 is 10ns slower than any other wait.
; Since it is OK for output to be a bit later, use JMP pin for LRCLK and latch on
; fall of BCLK so that all new LRCLK2 edges are low jitter.

.side_set 2

public entry_point:
.wrap_target
    jmp pin entry_point     side 0b11   ; Wait for LRCLK to fall
frame:
    wait 1 pin 0            side 0b11   ; Wait for BCLK
    wait 0 pin 0            side 0b11   ; Wait for BCLK to fall
    out pins, 1   [7]       side 0b00   ; First bit is from last I2S frame
    nop           [7]       side 0b00
    pull noblock  [7]       side 0b01
    set y, 30     [2]       side 0b01
bit0:
    nop           [4]       side 0b01 
    out pins, 1   [7]       side 0b00   ; 31 bits from the freshly pulled word
    nop           [7]       side 0b00
    nop           [7]       side 0b01
    jmp y-- bit0  [2]       side 0b01

    wait 1 pin 0            side 0b01   ; Resync to falling edge of BCLK
    wait 0 pin 0            side 0b01 
    out pins, 1   [7]       side 0b10   ; Last bit and signal second half of 96kHz frames
    nop           [7]       side 0b10
    pull noblock  [7]       side 0b11
    set y, 30     [1]       side 0b11   
bit1:
    nop           [5]       side 0b11
    out pins, 1   [7]       side 0b10   ; 31 bits from the newly pulled frame
    nop           [7]       side 0b10
    nop           [7]       side 0b11
    jmp y-- bit1  [1]       side 0b11   
    jmp pin frame           side 0b11   ; If this is second half of frame, don't wait for LRCLK fall
.wrap





% c-sdk {


static inline void tdm_in_init(PIO pio, int sm, int offset, int lrclk, int din, int divN, int divF ) 
{
    pio_gpio_init(pio, lrclk);        // TDM word clock - 50% duty cycle, falling edge for start
    pio_gpio_init(pio, din);          // Data in

    pio_sm_config sm_config = tdm_in_program_get_default_config(offset);
    sm_config_set_in_pins      (&sm_config, din);
    sm_config_set_jmp_pin      (&sm_config, lrclk);
    sm_config_set_in_shift     (&sm_config, false, false, 0);
    pio_sm_init(pio, sm, offset + tdm_in_offset_entry_point, &sm_config);
    pio_sm_exec_wait_blocking  (pio, sm, pio_encode_mov (pio_x, pio_null));     // Initialize the X and Y registers
    pio_sm_exec_wait_blocking  (pio, sm, pio_encode_mov (pio_y, pio_null));   
    uint32_t pin_mask = (1 << din) | (1 << lrclk);                                       // Everything synced off LR clock normal rate
    pio_sm_set_pindirs_with_mask(pio, sm, 0, pin_mask);
    pio_sm_set_clkdiv_int_frac          (pio, sm, divN, divF);
}

static inline void i2s_double_out_init(PIO pio, int sm, int offset, int bclk, int bclk2, int dout, int divN, int divF ) 
{
    pio_gpio_init(pio, bclk);         // I2S normal clock
    pio_gpio_init(pio, bclk+1);       // 
    pio_gpio_init(pio, dout);         // Data out
    pio_gpio_init(pio, bclk2);        // Bit clock at double rate
    pio_gpio_init(pio, bclk2+1);      // LR clock at double rate

    pio_sm_config sm_config = i2s_double_out_program_get_default_config(offset);
    sm_config_set_out_pins     (&sm_config, dout, 1);
    sm_config_set_in_pins      (&sm_config, bclk);
    sm_config_set_sideset_pins (&sm_config, bclk2);
    sm_config_set_jmp_pin      (&sm_config, bclk+1);
    sm_config_set_out_shift    (&sm_config, false, false, 32);
    pio_sm_init(pio, sm, offset + i2s_double_out_offset_entry_point, &sm_config);
    pio_sm_exec_wait_blocking  (pio, sm, pio_encode_mov (pio_x, pio_null));     // Initialize the X and Y registers
    pio_sm_exec_wait_blocking  (pio, sm, pio_encode_mov (pio_y, pio_null));   

    uint32_t pin_mask = (1 << dout) | (3 << bclk2);               // Data out and two clocks
    pio_sm_set_pins_with_mask(pio, sm, 0, pin_mask); 
    pio_sm_set_pindirs_with_mask(pio, sm, pin_mask, pin_mask);
    pin_mask = (3 << bclk);                                    // Everything synced off LR clock normal rate
    pio_sm_set_pindirs_with_mask(pio, sm, 0, pin_mask);

    pio_sm_set_clkdiv_int_frac          (pio, sm, divN, divF);
}

static inline void i2s_in(PIO pio, uint8_t sm, uint8_t offset, uint8_t pin_base) 
{
    pio_gpio_init(pio, pin_base + 0);       // DO
    pio_gpio_init(pio, pin_base + 1);       // DI
    pio_gpio_init(pio, pin_base + 2);       // BCLK
    pio_gpio_init(pio, pin_base + 3);       // LRCLK

    pio_sm_config sm_config = i2s_in_program_get_default_config(offset);
    sm_config_set_out_pins (&sm_config, pin_base, 1);
    sm_config_set_in_pins  (&sm_config, pin_base + 1);
    sm_config_set_jmp_pin  (&sm_config, pin_base + 3);
    sm_config_set_out_shift(&sm_config, false, false, 0);
    sm_config_set_in_shift (&sm_config, false, false, 0);
    pio_sm_init(pio, sm, offset, &sm_config);

    uint32_t pin_mask = (0b0000001 << pin_base);            // Single output pin
    pio_sm_set_pins_with_mask(pio, sm, 0, pin_mask); 
    pio_sm_set_pindirs_with_mask(pio, sm, pin_mask, pin_mask);

    pin_mask = (0b00001110 << pin_base);                    // Three input pins
    pio_sm_set_pindirs_with_mask(pio, sm, 0, pin_mask);
}

%}